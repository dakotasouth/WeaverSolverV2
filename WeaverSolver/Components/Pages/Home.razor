@page "/"


<MudMainContent>
    <MudContainer>
        <div class="game-board-container">
            <div class="game-board">
                <div class="start-row-container">
                    <div class="row start-row">
                        <!-- Top input row for letters -->
                        <input type="text" maxlength="1" class="block start-block"
                               @bind="topRowValues[0]"
                               @oninput="(e) => HandleInput(e, 0, true)"
                               @onkeydown="e => HandleBackspace(e, 0,true)"
                               @ref="topRowRefs[0]">
                        <input type="text" maxlength="1" class="block start-block"
                               @bind="topRowValues[1]"
                               @oninput="(e) => HandleInput(e, 1, true)"
                               @onkeydown="e => HandleBackspace(e, 1,true)"
                               @ref="topRowRefs[1]">
                        <input type="text" maxlength="1" class="block start-block"
                               @bind="topRowValues[2]"
                               @oninput="(e) => HandleInput(e, 2, true)"
                               @onkeydown="e => HandleBackspace(e, 2,true)"
                               @ref="topRowRefs[2]">
                        <input type="text" maxlength="1" class="block start-block"
                               @bind="topRowValues[3]"
                               @oninput="(e) => HandleInput(e, 3, true)"
                               @onkeydown="e => HandleBackspace(e, 3,true)"
                               @ref="topRowRefs[3]">
                        <input type="text" maxlength="1" class="block start-block"
                               @bind="topRowValues[4]"
                               @oninput="(e) => HandleInput(e, 4, true)"
                               @onkeydown="e => HandleBackspace(e, 4,true)"
                               @ref="topRowRefs[4]">

                    </div>
                </div>
                <div class="middle-row-container">
                    @if (solutionResult.Count > 0)
                    {
                        foreach (string word in solutionResult)
                        {
                            <div class="row">
                                @foreach (char letter in word)
                                {
                                    <div class="block middle-block">@letter</div>
                                }
                            </div>
                        }
                    }
                    else
                    {
                        <div class="row">
                            <div class="block middle-block"></div>
                            <div class="block middle-block"></div>
                            <div class="block middle-block"></div>
                            <div class="block middle-block"></div>
                            <div class="block middle-block"></div>
                        </div>
                    }
                </div>
                <div class="end-row-container">
                    <div class="row end-row">
                        <!-- Bottom input row for letters -->
                        <input type="text" maxlength="1" class="block end-block"
                               @bind="bottomRowValues[0]"
                               @oninput="e => HandleInput(e, 0, false)"
                               @onkeydown="e => HandleBackspace(e, 0, false)"
                               @ref="bottomRowRefs[0]">

                        <input type="text" maxlength="1" class="block end-block"
                               @bind="bottomRowValues[1]"
                               @oninput="(e) => HandleInput(e, 1, false)"
                               @onkeydown="e => HandleBackspace(e, 1, false)"
                               @ref="bottomRowRefs[1]">

                        <input type="text" maxlength="1" class="block end-block"
                               @bind="bottomRowValues[2]"
                               @oninput="(e) => HandleInput(e, 2, false)"
                               @onkeydown="e => HandleBackspace(e, 2, false)"
                               @ref="bottomRowRefs[2]">

                        <input type="text" maxlength="1" class="block end-block"
                               @bind="bottomRowValues[3]"
                               @oninput="(e) => HandleInput(e, 3, false)"
                               @onkeydown="e => HandleBackspace(e, 3, false)"
                               @ref="bottomRowRefs[3]">

                        <input type="text" maxlength="1" class="block end-block"
                               @bind="bottomRowValues[4]"
                               @oninput="(e) => HandleInput(e, 4, false)"
                               @onkeydown="e => HandleBackspace(e, 4, false)"
                               @ref="bottomRowRefs[4]">
                    </div>
                </div>
            </div>
        </div>

        <div class="button-container">
            <div>
                <MudButton Variant="Variant.Filled" @onclick="HandleReset">Reset</MudButton>
            </div>
            <MudSpacer />
            <div>
                <MudButton Variant="Variant.Filled" @onclick="HandleSolve">Solve</MudButton>
            </div>
        </div>
    </MudContainer>
</MudMainContent>

@code {
    private string[] topRowValues = new string[5];
    private string[] bottomRowValues = new string[5];

    private ElementReference[] topRowRefs = new ElementReference[5];
    private ElementReference[] bottomRowRefs = new ElementReference[5];

    private List<string> solutionResult = new List<string>();

    private async Task HandleEvent(ChangeEventArgs e)
    {
        await Task.Delay(1000);
    }

    private void HandleInput(ChangeEventArgs e, int index, bool isTopRow)
    {
        var letters = isTopRow ? topRowValues : bottomRowValues;
        var refs = isTopRow ? topRowRefs : bottomRowRefs;
        var value = e.Value?.ToString();

        letters[index] = value ?? "";

        if (!string.IsNullOrEmpty(value) && index < refs.Length - 1)
        {
            refs[index + 1].FocusAsync();
        }
    }

    private void HandleBackspace(KeyboardEventArgs e, int index, bool isTopRow)
    {
        var letters = isTopRow ? topRowValues : bottomRowValues;
        var refs = isTopRow ? topRowRefs : bottomRowRefs;

        if (e.Key == "Backspace" && index > 0)
        {
            refs[index - 1].FocusAsync();
        }
    }

    private void HandleSolve()
    {
        string set_start = string.Join("", topRowValues);
        string set_end = string.Join("", bottomRowValues);

        List<string> answer = solve_v3(set_start, set_end);

        solutionResult = answer;

        StateHasChanged();
    }

    private void HandleReset()
    {
        topRowValues = new string[5];
        bottomRowValues = new string[5];
        solutionResult = new List<string>();
    }


    List<string> get_neighbors(string word, HashSet<string> words_set)
    {
        List<string> neighbors = new List<string>();

        for (int i = 0; i < 5; i++)
        {
            foreach (char letter in "abcdefghijklmnopqrstuvwxyz")
            {
                string new_word = word.Substring(0, i) + letter + word.Substring(i + 1);

                if (new_word != word && words_set.Contains(new_word))
                {
                    neighbors.Add(new_word);
                }
            }
        }

        return neighbors;
    }

    List<string> solve_v3(string set_start, string set_end)
    {
        if (set_start.Length != 5 || set_end.Length != 5 || set_start == set_end || !set_start.All(char.IsLetter) || !set_end.All(char.IsLetter))
        {
            // Invalid input
            return new List<string>();
        }

        HashSet<string> words_set = new HashSet<string>();

        using (StreamReader wordListFile = new StreamReader("./Data/words5.txt"))
        {
            string fileContent = wordListFile.ReadToEnd();
            string[] file_words = fileContent.Split(", ");
            words_set = new HashSet<string>(file_words.Select(word => word.Substring(1, 5)));
        }

        set_start = set_start.ToLower();
        set_end = set_end.ToLower();

        if (!words_set.Contains(set_start) || !words_set.Contains(set_end))
        {
            return new List<string>();
        }

        words_set.Remove(set_start);

        Queue<List<string>> q = new Queue<List<string>>();
        q.Enqueue(new List<string> { set_start });

        while (q.Count > 0)
        {
            List<string> curr_path = q.Dequeue();
            string curr_word = curr_path.Last();

            if (curr_word == set_end)
            {
                // Found a path
                List<string> answer = curr_path.Select(x => x.ToUpper()).ToList();
                return answer;
            }

            List<string> neighbors = get_neighbors(curr_word, words_set);

            foreach (string neighbor in neighbors)
            {
                words_set.Remove(neighbor);
                List<string> new_path = new List<string>(curr_path);
                new_path.Add(neighbor);
                q.Enqueue(new_path);
            }
        }

        return new List<string>();
    }
}

